---
id: examples
title: nearlib examples
sidebar_label: Examples
---

## overview

This page includes several examples of using `nearlib` presented as a collection of code snippets.

`nearlib` is a JavaScript/TypeScript library for development of DApps on the NEAR platform that can be used from any client or server-side JavaScript environment.

Every code snippet on this page will work as expected if you copy and paste it into a "working context" by which we mean something like the **Playground** presented in the [introduction to `nearlib`](introduction).

Most of these examples either come directly from, or were heavily inspired by, the `nearlib` test suite. You can see the [code on GitHub](https://github.com/nearprotocol/nearlib/tree/master/test) if you're into that sort of thing.

Keep in mind the `nearlib` source has two main folders with hand-crafted code.
- `/src.ts`
- `/test`

*All other folders in this repository are generated by automated scripts (see `package.json` in the repo for details)*

So, when looking for a feature of `nearlib` in the source code, know that the `src.ts` folder is the authority for functionality and `test` contains the code that exercises all of this functionality.  The rest of the repo can (should?) be safely ignored.

<blockquote class="warning">
<strong>heads up</strong><br><br>

This document assumes you:

- already have a basic understanding of `nearlib` which includes
  - how to include it in your client or server-side JavaScript project
  - how to connect to the NEAR network
- already know how to work with [async / await](https://javascript.info/async-await) syntax in JavaScript

For a refresher on these topics, please check out the [introduction to `nearlib`](introduction).

</blockquote>

It's also worth mentioning now in case these examples seem overly simplistic that, for expediency in learning, the code below doesn't follow best practices.  We add various properties to the `window` object, for example.  While this is clearly not good practice in general (because it pollutes the global namespace) it's very useful for quick prototyping from the JavaScript Developer Console because it's easier for you to move through these examples while testing and validating your understanding along the way.

In your own code, consider best practices as you normally would. The examples on this page are intended to minimize the time and effort required to become productive while learning.  Exercise your own best judgement when building applications for your users in the wild.

For our take on best practices with `nearlib` and the rest of the NEAR platform, take a look at our [GitHub org](https://github.com/nearprotocol) and star a few of our internal tools like NEAR Shell, NEAR Wallet and NEAR Explorer, all of which use `nearlib` under the hood.  You can also [subscribe to our newsletter](https://nearprotocol.com/newsletter/) for updates about our starter kits, beta products and new tools as we release them the community.

Happy hacking!

## `nearlib` at 1000ft

This section introduces `nearlib` at a very high level in an attempt to keep the "map" in full view.  If at any point while working with `nearlb` you find something doesn't make sense, this section should help you put it back in context.  Either that or we need to make some adjustments!  So don't hold back with those [issues](https://github.com/nearprotocol/nearlib/issues) and [pull requests](https://github.com/nearprotocol/nearlib/pulls) -- we remain very receptive to developer feedback.

To begin, the playground presented in the [introduction to `nearlib`](introduction) surfaces 3 objects including:
- `nearlib` (the library, the SDK, the big enchilada tostada)
- `near` (the connection object returned by a call to `nearlib.connect()`)
- `wallet` (convenience methods for authentication and credential management)

<br>

### the `nearlib` interface

This is the reference to the top level `nearlib` SDK ([view source](https://github.com/nearprotocol/nearlib/blob/master/src.ts/))

**classes / constructors**
- `nearlib.Account` represents an account on the NEAR platform
- `nearlib.Connection` represents a connection to the NEAR platform
- `nearlib.Contract` represents a Smart Contract on the NEAR platform
- `nearlib.InMemorySigner` is used for signing transactions before they're sent to the network
- `nearlib.KeyPair` is used to generate new key pairs
- `nearlib.WalletAccount` is used to instantiate a `wallet` (as per the big 3 above)

**utility collections**
- `nearlib.keyStores` surfaces various key stores including
  - `BrowserLocalStorageKeyStore` for client-side development (stores keys in `LocalStorage`)
  - `UnencryptedFileSystemKeyStore` for server-side development (stores keys in `./neardev/${network}/${account}.json`)
  - `InMemoryKeyStore` for testing
  - and `MergeKeyStore` to support any combination of the above
- `nearlib.transactions` surfaces transaction factory methods (ie. `nearlib.transactions.addKey()` produces a hydrated `AddKey` transaction ready for serialization and signing before being sent to the network) and their parameters (ie. `FunctionCallPermission` is a type of `AccessKey` that may be used as a parameter to the `addKey()` method)
- `nearlib.utils` surfaces various utility classes and functions including
  - `KeyPairEd25519` for key pair generation using the ed25519 algorithm
  - and serialization utilities `base_encode`, `base_decode`, `serialize` and `deserialize`
- `nearlib.providers` surfaces access to the `JsonRpcProvider` which wraps the RPC interface

**methods**
- `nearlib.connect(config)` returns a `near` connection object given a configuration object as per the [introduction to `nearlib`](introduction)
- `nearlib.providers.getTransactionLastResult(fxo)` returns the result of the last transaction given a `FinalExecutionOutcome` object (the value returned after sending a signed transaction to the network)

<br>

### the `near` connection interface

This is an instance of the `nearlib.Connection` class ([view source](https://github.com/nearprotocol/nearlib/blob/master/src.ts/connection.ts))

**objects**
- `near.config` exposes the original configuration data passed in at connection time
- `near.connection.provider` exposes the `JsonRpcProvider`
- `near.connection.signer` exposes the `InMemorySigner`

**methods**
- `near.connect(account)` returns a reference to a validated and fully hydrated account on the network
- `near.loadContract(contract, options)` loads a previously deployed Smart Contract from the NEAR network for access in your client or server-side JavaScript.
- ~~`near.sendTokens(amount, sender, receiver)`~~ (deprecated, use `account.sendMoney()` instead)

<br>

### the `wallet` interface

This is an instance of the `nearlib.WalletAccount` class ([view source](https://github.com/nearprotocol/nearlib/blob/master/src.ts/wallet-account.ts))

**methods**
- `wallet.requestSignIn(contract, appTitle, successUrl, failureUrl)` directs the current window through the NEAR Wallet authorization flow and back
- `wallet.isSignedIn()` returns a boolean indicator of signed-in status
- `wallet.getAccountId()` returns the name of the wallet account currently signed (as a string)
- `wallet.signOut()` removes the `LocalStorage` entry that represents an authorized `WalletAccount` but leaves private keys intact

<blockquote class="info">
<strong>did you know?</strong><br><br>

[NEAR Studio](http://near.dev/) includes several starter projects where you can see `nearlib`, the `near` connection and the `wallet` in action by looking at `main.js` in the `src` folder.  If you happen to notice a `main.ts` in the `assembly` folder, well, that's a contract.

</blockquote>

## `nearlib` in pictures

`nearlib` surfaces NEAR primitives as first class objects and facilitates communicate with the NEAR platform through our JSON-RPC interface.

```text
                                    o ----------------------- o
                                    |                         |
          o ----------- o           |  +-------------------+  |
   use    |             |  ------>  |  |                   |  |
 -------> |   nearlib   |    RPC    |  |   NEAR platform   |  |
          |             |  <------  |  |                   |  |
          o ----------- o           |  +-------------------+  |
                                    |                         |
                                    o ----------------------- o
```

If we zoom in on `nearlib` a little we'll notice a few key components that we can explore more deeply.

```text
   nearlib (zoomed in)
 o ------------------------------------------------------------------------ o
|                                            --                              |
|             o -------- o  --->  o ------- o  |                             |
|             | Contract |        | Account |  |                             |
|             o -------- o  <---  o ------- o  |                             |
|                                              |                             |
|                           o ------------- o  |                             |
|                           | WalletAccount |  |                             |
|                           o ------------- o  |                             |
|                                              |                             |
|                             o ----------- o  |                             |
|                             | Transaction |  |                             |
|                             o ----------- o  |                             |
|                                              |  --->  o --------------- o  |  ------>
|                             --               |        | JsonRpcProvider |  |    RPC
|                            |    o ------- o  |  <---  o --------------- o  |  <------
|                            |    | KeyPair |  |                             |
|  o -------------- o  --->  |    o ------- o  |                             |
|  | InMemorySigner |        |                 |                             |
|  o -------------- o  <---  |  o --------- o  |                             |
|                            |  | KeyStores |  |                             |
|                            |  o --------- o  |                             |
|                             --               |                             |
|                                              |                             |
|                               o --------- o  |                             |
|                               | Utilities |  |                             |
|                               o --------- o  |                             |
|                                            --                              |
 o ------------------------------------------------------------------------ o
```

The appreciate the structure here, it's worth discussing a single illustrative example.  Briefly, all communications with the NEAR platform pass through `JsonRpcProvider`.  Anything else that's happening in `nearlib` is intended to make our lives as developers easier.

And of course the fact that this is JavaScript is equally arbitrary -- we could do the same with Java, C#, Ruby, Elixir, or any other language binding you prefer.  The key is the JSON RPC interface with the NEAR platform.

So, starting right at the top of the diagram above ...

## levels of abstraction

<blockquote class="lesson">
<strong>your turn</strong> <span>Explore the helpful abstractions provided by <code>nearlib</code></span><br><br>

- time to complete: **10 mins**
- level of difficulty: **trivial**
- prerequisites
  - make sure you already have your developer account setup via NEAR Wallet
  - confirm you have access to `nearlib`, `near` and `wallet` in the console (see [prepare your playground](introduction#prepare-your-playground))
</blockquote>

`Contract` represents a Smart Contract on the NEAR platform.

Looking at the [source code for the `Contract` class](https://github.com/nearprotocol/nearlib/blob/master/src.ts/contract.ts) we see its constructor adds `view` and `change` methods as function attributes of a new contract instance.  This is a useful abstraction to help us reason about contracts as first class citizens in our application.  But what's actually happening under the hood is that `view` and `change` methods on a contract instance are just proxies for an `Account`s `viewFunction` and `functionCall` methods.  These, in turn, are just proxies for JSON RPC calls via `JsonRpcProvider`.

Of course there's more going on here than just a simple game of "hot potato" (passing something from one person to another without thinking).  These interfaces are often handling some basic data validation or sanitizing inputs and return values.  But the general structure is the same throughout `nearlib` -- anything you do that touches the network ends up as a JSON RPC call handled by `JsonRpcProvider` which itself relies on the [popular `fetch` library](https://github.com/nearprotocol/nearlib/blob/3b37c330e9c00daf087c483d0e57d6e1b30f6647/src.ts/utils/web.ts#L39) under the hood.

<ol class="steps">

<li>consider the highest level of abstraction available for calling a Smart Contract method</li>

*The following code is adapted from the [NEAR Studio Counter Smart Contract](http://near.dev/) so have a look there quickly if this is your first time working with the NEAR platform because the code below will seem much clearer to you once you've taken 10 minutes to play with the Counter Smart Contract example and skimmed the code in `src/main.js`.*

It's not necessary, but you can copy and paste the code below into your **Playground**.

```js
// ABSTRACTION: high
// -----------------------------------------------------------------------------
// at the highest level of abstraction: using the Contract object
// -----------------------------------------------------------------------------

// Initializing our contract APIs by contract name and configuration.
let contractName = "my-counter-contract" // contract names must be globally unique

// this approach has been deprecated but appears in many examples
window.contract = await near.loadContract(contractName, {
  viewMethods: ['getCounter'],
  changeMethods: [ /* removed for simplicity */ ],
  sender: wallet.getAccountId()
});

// invoking the method will throw an error since the contract doesn't exist
// window.contract.getCounter()
// uncomment and use the line above to try calling the method on the fake contract
```

The code above produces an instance of the `Contract` object that exposes a single `view` method called `getCounter`

<blockquote class="info">
<strong>did you know?</strong><br><br>

`view` methods don't change the state of the blockchain, as opposed to `change` methods which do, and therefore require a cryptographic signature, cost a little more to compute and take a little longer to process since they're execution is recorded permanently on the blockchain (which requires consensus)

</blockquote>

<li>consider an alternate version of the code above for calling a Smart Contract method</li>

It's not necessary, but you can copy and paste the code below into your **Playground**.

```js
// ABSTRACTION: high
// -----------------------------------------------------------------------------
// STILL at the highest level of abstraction: using the Contract object
// but this is ANOTHER APPROACH to the same thing: loading a contract instance
// We include this here because the code above displays a deprecation warning
// -----------------------------------------------------------------------------
await (async () => {
  // same contract name as above
  let contractName = "my-counter-contract" // contract names must be globally unique

  // this time get a reference to an account first
  let account = await getAuthorizedAccount()

  // then create a new contract instance
  window.contract = new nearlib.Contract(account, contractName, {
    viewMethods: ['getCounter'],
    changeMethods: [ /* removed for simplicity */ ],
  });

  // ---------------------------------------------------------------------------
  // helper function to keep code above a little cleaner
  async function getAuthorizedAccount(){
    try {
      return await near.account(wallet.getAccountId())
    } catch(e){
      // this approach throws an exception if we haven't authorized NEAR Wallet first
      if(/Account ID/.test(e.message)) {
        console.warn("you should authorize this app using NEAR Wallet first")
      } else {
        console.log(e.type, e.message)
      }
    }
  }
})()

// if you're already logged in with NEAR Wallet, then invoking the contract method
// we just setup will throw an error since the contract doesn't actually exist
// window.contract.getCounter()
// uncomment and use the line above to try calling the method on the fake contract
```

<blockquote class="warning">
<strong>heads up</strong><br><br>

Actually calling the contract method in the 2 code snippets above (and the next few in this discussion) **will throw an error because the contract account doesn't exist** (at least it didn't at the time of writing)

---

`Uncaught (in promise) Error: Querying call/my-counter-contract/getCounter failed: ` \
`Account "my-counter-contract" doesn't exist.`  \
`{`  \
`  "error": "Account \"my-counter-contract\" doesn't exist",`  \
`  "logs": []`  \
`}`

---

But why are we getting an `Account`-related error when we're working with a Smart Contract here?

Well, contracts have accounts too because they're first class citizens on the network with their own storage and compute budgets. You can read more about `Account`s on the NEAR platform in the [Nearnomicon](http://nomicon.io/Primitives/Account.html).

</blockquote>

<li>Consider a lower level of abstraction to do the same. This is somewhere "in the middle" of the layers of abstractions made available by nearlib</li>

It's not necessary, but you can copy and paste the code below into your **Playground**.

```js
// ABSTRACTION: middle
// -----------------------------------------------------------------------------
// a little lower in the abstraction hierarchy: using the Account object
// -----------------------------------------------------------------------------
await (async () => {
  let contractName = "my-counter-contract" // contract names must be globally unique
  let methodName = "getCounter"

  window.contract = {
    getCounter: async (args) => {
      let account = await getAuthorizedAccount()
      account.viewFunction(contractName, methodName, args || {});
    }
  }

  // ---------------------------------------------------------------------------
  // helper function to keep code above a little cleaner
  async function getAuthorizedAccount(){
    try {
      return await near.account(wallet.getAccountId())
    } catch(e){
      // this approach throws an exception if we haven't authorized NEAR Wallet first
      if(/Account ID/.test(e.message)) {
        console.warn("you should authorize this app using NEAR Wallet first")
      } else {
        console.log(e.type, e.message)
      }
    }
  }
})()
```

<li>Consider the lowest level of abstraction made available by nearlib</li>

It's not necessary, but you can copy and paste the code below into your **Playground**.

```js
// ABSTRACTION: low
// -----------------------------------------------------------------------------
// now at the lowest level of abstraction: using JsonRpcProvider directly
// -----------------------------------------------------------------------------
await (async () => {
  let contractName = "my-counter-contract" // contract names must be globally unique
  let methodName = "getCounter"
  let methodArgs = {}
  let encodedArguments = nearlib.utils.serialize.base_encode(JSON.stringify(methodArgs))

  window.contract = {
    getCounter: async (args) => {
      let account = await getAuthorizedAccount()
      account.connection.provider.query(`call/${contractName}/${methodName}`, encodedArguments)
    }
  }

  // ---------------------------------------------------------------------------
  // helper function to keep code above a little cleaner
  async function getAuthorizedAccount(){
    try {
      return await near.account(wallet.getAccountId())
    } catch(e){
      // this approach throws an exception if we haven't authorized NEAR Wallet first
      if(/Account ID/.test(e.message)) {
        console.warn("you should authorize this app using NEAR Wallet first")
      } else {
        console.log(e.type, e.message)
      }
    }
  }
})()
```

</ol>

#### Did it work?

**You'll know it worked** when you see the output of the code above and the only errors are those related to the contract account not being found (assuming no one actually adds it after seeing this note just to troll you ;)

#### Did something go wrong?

**If you saw something** about a console warning that you need to login to NEAR Wallet then you should do that because the call to `wallet.getAccountId()` won't return proper data unless you're logged in.  You can check if you're logged in by calling that very method or by inspecting your `LocalStorage` and noting at least 1 private key there that's associated with the account you're trying to use.  If any of this is disorienting then your best bet it to revisit the [introduction to `nearlib`](introduction) that covers these details.

<blockquote class="success">
<strong>finished!</strong><br><br>

You should now have a good sense of how `nearlib` handles communications with the NEAR network and the benefits of using `nearlib` in your own applications.  The NEAR engineering team is committed to maintaining the highest possible quality of language bindings possible including JavaScript via `nearlib` and Rust via `near-bindgen`.  If you have any suggestions for improvement, comments or nits about your experience with `nearlib`, we're all ears.  Please [submit an issue](https://github.com/nearprotocol/nearlib/issues), comment on existing issues and [submit pull requests](https://github.com/nearprotocol/nearlib/pulls).  We welcome your contributions!

</blockquote>


## zooming in

Some parts of `nearlib` are better seen first because it will help you make sense of the library as a whole.

The following short list of code snippets and examples should quickly give you a sense of how `nearlib` works under ths hood.

If you feel like any of this could be improved, please share your thoughts by submitting an issue to the [documentation repo](https://github.com/nearprotocol/docs/issues).

### `JsonRpcProvider`

This class provides connectivity to the NEAR platform.  It is used by all other parts of `nearlib` when interacting with the NEAR network to send transactions.  `JsonRpcProvider` can also be used as a standalone utility for querying the network via RPC calls directly for network status, processed transactions, blocks and chunks on the network.

Here we've included the Typescript interface for `JsonRpcProvider` to make it clear which types are accepted as parameters and returned by the method calls.

```ts
// DO NOT TRY TO RUN THIS (it's incomplete TypeScript)
class JsonRpcProvider extends Provider {
  async status(): Promise<NodeStatusResult> {}
  async block(blockId: BlockId): Promise<BlockResult> {}
  async chunk(chunkId: ChunkId): Promise<ChunkResult> {}
  async txStatus(txHash: Uint8Array, accountId: string): Promise<FinalExecutionOutcome> {}
  async query(path: string, data: string): Promise<any> {}
  async sendTransaction(signedTransaction: SignedTransaction): Promise<FinalExecutionOutcome> {}
}
```
*[view source on Github](https://github.com/nearprotocol/nearlib/blob/master/src.ts/providers/json-rpc-provider.ts)*

Moving through this interface one method at a time ...


#### `near.connection.provider.status()`

This method returns a [NodeStatusResult](https://github.com/nearprotocol/nearlib/blob/3b37c330e9c00daf087c483d0e57d6e1b30f6647/src.ts/providers/provider.ts#L14) which is good for getting the latest block hash or height, a list of validators, and a few other high level network details

```js
await near.connection.provider.status()
```

#### `near.connection.provider.block`

This method returns a [`BlockView`](https://github.com/nearprotocol/nearcore/blob/324b42e70166bb17fcf2435c2d75365c1f12ac24/core/primitives/src/views.rs#L445), one of NEAR platform's primitives, which itself is made up of a `BlockHeaderView` and a collection of `ChunkHeaderView`s

```js
// using the previous snippet to pull the latest block hash
let chain = (await near.connection.provider.status()).sync_info
let hash = chain.latest_block_hash // <-- note hash vs height

// we can pass the results to the provider.block method
await near.connection.provider.block(hash)
```

```js
// using the previous snippet to pull the latest block hash
let chain = (await near.connection.provider.status()).sync_info
let number = chain.latest_block_height // <-- note height vs hash

// we can pass the results to the provider.block method
await near.connection.provider.block(number)
```

#### `near.connection.provider.chunk`

This method returns a [`ChunkView`](https://github.com/nearprotocol/nearcore/blob/324b42e70166bb17fcf2435c2d75365c1f12ac24/core/primitives/src/views.rs#L460), one of NEAR platform's primitives, which itself is made up of a `ChunkHeaderView` and a collection of `SignedTransactionView`s and a collection of `ReceiptView`s

The code snippet below is too short to be useful except as an illustration.  If you actually want to see results from the live network then the chunk hash should be queried using the [provider.block](#nearconnectionproviderchunk) snippets above.  Chunks are returned as a collection attached to a block.

*To avoid a longer example, a chunk hash was taken from the live network at time of writing but this may be invalid when you run it since it's a Testnet artifact which may be restarted.  With Mainnet we could assume this would exist as long as the network survives.*

```js
// best to fetch this chunk hash using the code above
// if this call fails it's because this chunk hash is no longer valid
let hash = "6SrBkhwVLAZC2YQJG3YUSef2UGf7UxwpsLZEY3dsZMKb"
await near.connection.provider.chunk(hash)
```

```js
// to see a list of transactions processed on a block we have to map the
// collection of [chunk_hash]es to chunks
let block = await near.connection.provider.block("A2AbjnAx9gbZNBE8URjWJB6gQy7wZEWuanZaQhkeE7pw")
let chunkFromChunkHash = async c => { return await near.connection.provider.chunk(c.chunk_hash) }
await Promise.all(block.chunks.map(chunkFromChunkHash))

// and there we will find the transaction that was available at the time of writing
// in the 4th chunk of this block, along with some chunk header info, this transaction:
// {
//   transactions: [
//     {
//       actions: [{…}]
//       hash: "3L37n7LowxfpFEJcQvYmoQPo4NpgV2ZUmr4vXSBYhxPL"
//       nonce: 14
//       public_key: "ed25519:91G4Y3jJk5hwYWQm4BZLVDLWh52axtjmc42P2VtyKh4"
//       receiver_id: "cruz"
//       signature: "ed25519:44mZ1CSMm1Ybku51413QTPS43gN7iSHkRBt1oFd2hdtu8Z2HFgsKr6CLGaCTKY3rwTcJnB3AWtGu1zZdb2DYbGqA"
//       signer_id: "cruz"
//     }
//   ]
// }
```

#### `near.connection.provider.txStatus`

This method returns a [`ChunkView`](https://github.com/nearprotocol/nearcore/blob/324b42e70166bb17fcf2435c2d75365c1f12ac24/core/primitives/src/views.rs#L460), one of NEAR platform's primitives, which itself is made up of a `ChunkHeaderView` and a collection of `SignedTransactionView`s and a collection of `ReceiptView`s

The code snippet below is too short to be useful except as an illustration.  A better example would use a transaction hash from a recent transaction that you sent to the network.

*To avoid a longer example, a transaction hash was taken from the live network at time of writing but this may be invalid when you run it since it's a Testnet artifact which may be restarted.  With Mainnet we could assume this would exist as long as the network survives.*

```js
// best to fetch this transaction hash using a call to the live network
// if this call fails it's because this transaction hash is no longer valid
let txHash = "3L37n7LowxfpFEJcQvYmoQPo4NpgV2ZUmr4vXSBYhxPL"
let decodedTxHash = nearlib.utils.serialize.base_decode("3L37n7LowxfpFEJcQvYmoQPo4NpgV2ZUmr4vXSBYhxPL")
await near.connection.provider.txStatus(decodedTxHash, '')
```

#### `near.connection.provider.query`

This method accepts RPC paths and returns their results as JSON.

```js
// this will return an AccountState for any account
let account = "test.near"
let state = await near.connection.provider.query(`account/${account}`, "");
console.table(state)
```

```js
// this will return all access keys for any account
let account = "test.near"
let keys = await near.connection.provider.query(`access_key/${account}`, '');
console.dir(keys)
```

#### `near.connection.provider.sendTransaction`

### `Account`

This class represents an account on the NEAR platform.  It has a number of convenience methods that wrap valid transactions on the network and, if a call to `account.state()` does not throw an error then you can be sure that you have (a) a valid account ID that (b) exists on the networkId which you passed via the connection configuration and (c) you have at least one private key for which the account ID has a matching public access key (either `FullAccess` permissions or `FunctionCall` access permissions)


<blockquote class="info">
<strong>did you know?</strong><br><br>

Calling `await account.state()` on an account object validates *and* hydrates the object at the same time if you have control of at least one private key associated with the account already available in your `LocalStorage` (or `./neardev/${networkId}` folder for server-side development)

There are 3 possible outcomes of a call to `await account.state()`:

(1) If the call succeeds you will see a hydrated account object returned to the console

```json
{
  "amount": "20000001999372696601",
  "code_hash": "11111111111111111111111111111111",
  "locked": "0",
  "storage_paid_at": 1798245,
  "storage_usage": 1366
}

/**
  Note the above is actually an AccountState struct as JSON but it's the most
  visible part of a valid Account object in the JavaScript Developer Console.
  The same object also includes a reference to the Account object through its
  prototype
*/
```

(2) If you call `await account.state()` on an Account object using an account that **does not exist** on the configured network `account.connection.networkId` then you will see the following error:
> <span class="error">`Server error: account ${accountId} does not exist while viewing`</span>

(3) If you call `await` to instantiate a new Account object without having the proper credentials you will see the following message emitted via `console.log` (client-side) or to `stdout` (server-side).
> `Missing public key for ${accountId} in default`

</blockquote>

Here we've included the Typescript interface for `Account` to make it clear which types are accepted as parameters and returned by the method calls.

```ts
// account hydration and validation
async fetchState(): Promise<void> {}
async state(): Promise<AccountState> {}

// account management
async createAccount(newAccountId: string, publicKey: string | PublicKey, amount: BN): Promise<FinalExecutionOutcome>  {}
async deleteAccount(beneficiaryId: string): Promise<FinalExecutionOutcome> {}

// access key management
async addKey(publicKey: string | PublicKey, contractId?: string, methodName?: string, amount?: BN): Promise<FinalExecutionOutcome> {}
async deleteKey(publicKey: string | PublicKey): Promise<FinalExecutionOutcome> {}
async getAccessKeys(): Promise<any> {}
async getAccountDetails(): Promise<any> {}

// contract management
async deployContract(data: Uint8Array): Promise<FinalExecutionOutcome> {}
async createAndDeployContract(contractId: string, publicKey: string | PublicKey, data: Uint8Array, amount: BN): Promise<Account> {}

// function invocation on Smart Contracts
async viewFunction(contractId: string, methodName: string, args: any): Promise<any> {}
async functionCall(contractId: string, methodName: string, args: any, gas: number, amount?: BN): Promise<FinalExecutionOutcome> {}

// sending money to other accounts and staking (also sending money that you get back if you behave)
async sendMoney(receiverId: string, amount: BN): Promise<FinalExecutionOutcome> {}
async stake(publicKey: string | PublicKey, amount: BN): Promise<FinalExecutionOutcome> {}

// the method below could arguably be made public
private async signAndSendTransaction(receiverId: string, actions: Action[]): Promise<FinalExecutionOutcome> {}
```

*[view source on GitHub](https://github.com/nearprotocol/nearlib/blob/master/src.ts/account.ts)*

---

<blockquote class="warning">
<strong>work in progress</strong> <span>expect the following content soon</span><br><br>

 - zooming in
   - Account
     - interface examples
   - Transaction
     - interface examples

- cookbook
  - create an account
  - create a transaction
  - sign a transaction
  - send a transaction

</blockquote>
